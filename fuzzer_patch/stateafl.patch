--- a/afl-fuzz.c	2025-12-27 15:07:18.897875489 +0800
+++ b/afl-fuzz.c	2025-12-27 15:38:05.872007234 +0800
@@ -746,6 +746,7 @@
   return result;
 }
 
+EXP_ST int score_log_fd = 0x0;
 /* Select a seed to exercise the target state */
 struct queue_entry *choose_seed(u32 target_state_id, u8 mode)
 {
@@ -821,7 +822,12 @@
   } else {
     PFATAL("AFLNet - the states hashtable has no entries for state %d", target_state_id);
   }
-
+  u8 choose_buf[0x100];
+  memset(choose_buf, 0x0, 0x100);
+  sprintf(choose_buf, "state %u, choose %s\n", target_state_id, result->fname);
+  if(score_log_fd > 0){
+    write(score_log_fd, choose_buf, strlen(choose_buf));
+  }
   return result;
 }
 
@@ -5694,6 +5700,10 @@
   if (delete_files(fn, "")) goto dir_cleanup_failed;
   ck_free(fn);
 
+  fn = alloc_printf("%s/state_seeds", out_dir);
+  if (delete_files(fn, "")) goto dir_cleanup_failed;
+  ck_free(fn);
+
   /* And now, for some finishing touches. */
 
   fn = alloc_printf("%s/.cur_input", out_dir);
@@ -5741,6 +5751,26 @@
 
 /* A spiffy retro stats screen! This is called every stats_update_freq
    execve() calls, plus in several other circumstances. */
+EXP_ST int score_log_time = 0x0;
+#define SCORE_LOG_FREQ 0x8
+
+static void setup_score_log(void){
+  u8 name_buf[0x100];
+  memset(name_buf, 0x0, 0x100);
+  sprintf(name_buf, "%s/score_log.txt", out_dir);
+  score_log_fd = open(name_buf, O_CREAT | O_RDWR, 0666);
+  if(score_log_fd < 0){
+    PFATAL("score log file create fail");
+  }
+  return;
+}
+
+static void destroy_score_log(void){
+  if(score_log_fd > 0){
+    close(score_log_fd);
+  }
+  return;
+}
 
 static void show_stats(void) {
 
@@ -6221,8 +6251,18 @@
         state = kh_val(khms_states, k);
         SAYF(cRST "S%-3s:%-4s,"cCYA "%-5s,"cLRD "%-5s,"cGRA "%-5s",  DI(state->id), DI(state->selected_times), DI(state->fuzzs), DI(state->paths_discovered), DI(state->paths));
         if ((i + 1) % 3 == 0) SAYF("\n");
+        if(!((score_log_time) % (SCORE_LOG_FREQ))){
+          u32 score = ceil(1000 * pow(2, -log10(log10(state->fuzzs + 1) * state->selected_times + 1)) * pow(2, log(state->paths_discovered + 1)));
+          u8 score_buf[0x100];
+          memset(score_buf, 0x0, 0x100);
+          sprintf(score_buf, "%u|%u|%u|%u|%u\n", state_id, state->selected_times, state->fuzzs, state->paths_discovered, score);
+          if(score_log_fd > 0){
+            write(score_log_fd, score_buf, strlen(score_buf));
+          }
+        }
       }
     }
+    score_log_time++;
   }
 
   /* Hallelujah! */
@@ -9493,6 +9533,10 @@
   if (mkdir(tmp, 0700)) PFATAL("Unable to create '%s'", tmp);
   ck_free(tmp);
 
+  tmp = alloc_printf("%s/state_seeds", out_dir);
+  if (mkdir(tmp, 0700)) PFATAL("Unable to create '%s'", tmp);
+  ck_free(tmp);
+
   /* All recorded paths in structure files. */
 
   tmp = alloc_printf("%s/replayable-queue", out_dir);
@@ -10493,6 +10537,7 @@
 
   if (!out_file) setup_stdio_file();
 
+  setup_score_log();
   check_binary(argv[optind]);
 
   start_time = get_cur_time();
@@ -10686,6 +10731,58 @@
 
 stop_fuzzing:
 
+  for(int i = 0; i < state_ids_count; i++){
+    state_info_t *state_info;
+    u32 state_id = state_ids[i];
+    khint_t k = kh_get(hms, khms_states, state_id);
+    if(k != kh_end(khms_states)){
+      state_info = kh_val(khms_states, k);
+      printf("[*]dealing with state %d\n", state_id);
+      for(int seed_idx = 0; seed_idx < state_info->seeds_count; seed_idx++){
+        struct queue_entry *seed = state_info->seeds[seed_idx];
+        printf("[*]dealing with state %d, seed %d:%s\n", state_id, seed_idx, seed->fname);
+        u32 total_region = seed->region_count;
+        u32 M2_start_region_ID = 0;
+        u32 region_fail = 0x0;
+        if (state_aware_mode) {
+          u32 total_region = seed->region_count;
+          if (total_region == 0) PFATAL("0 region found for %s", seed->fname);
+          if (state_id == 0) {
+            M2_start_region_ID = 0;
+            //do not calculate region count
+          } else {
+            M2_start_region_ID = 0;
+
+            //Identify M2_start_region_ID first based on the target_state_id
+            for(int j = 0; j < seed->region_count; j++) {
+              u32 regionalStateCount = seed->regions[j].state_count;
+              if (regionalStateCount > 0) {
+                //reachableStateID is the last ID in the state_sequence
+                u32 reachableStateID = seed->regions[j].state_sequence[regionalStateCount - 1];
+                M2_start_region_ID++;
+                if (reachableStateID == state_id) break;
+              } else {
+                region_fail = 0x1;
+              }
+            }
+            //Handle corner case(s) and skip the current queue entry
+            if (M2_start_region_ID >= queue_cur->region_count) region_fail = 0x1;
+            if(region_fail){
+              printf("[!]seed %d of state %d failed\n", seed_idx, state_id);
+              region_fail = 0x0;
+              continue;
+            }
+          }
+          kl_messages = construct_kl_messages(seed->fname, seed->regions, M2_start_region_ID);
+          u8 *save_name = alloc_printf("%s/state_seeds/state_%d_origin_%d", out_dir, state_id, seed_idx);
+          save_kl_messages_to_file(kl_messages, save_name, 1, seed->region_count);
+        }
+      }
+    }
+    else{
+      printf("[!]invalid state %d\n", state_id);
+    }
+  }
   SAYF(CURSOR_SHOW cLRD "\n\n+++ Testing aborted %s +++\n" cRST,
        stop_soon == 2 ? "programmatically" : "by user");
 
@@ -10711,7 +10808,7 @@
   ck_free(wd_vanilla);
 
   destroy_ipsm();
-
+  destroy_score_log();
   alloc_report();
 
   OKF("We're done here. Have a nice day!\n");
