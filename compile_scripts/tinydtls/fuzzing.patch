--- a/dtls.c	2025-12-08 16:07:37.473886419 +0800
+++ b/dtls.c	2025-12-08 16:09:58.040623159 +0800
@@ -281,60 +281,15 @@
 		   session_t *session,
 		   uint8_t *msg, size_t msglen,
 		   uint8_t *cookie, int *clen) {
-  unsigned char buf[DTLS_HMAC_MAX];
-  size_t len, e;
-
-  /* create cookie with HMAC-SHA256 over:
-   * - SECRET
-   * - session parameters (only IP address?)
-   * - client version 
-   * - random gmt and bytes
-   * - session id
-   * - cipher_suites 
-   * - compression method
-   */
-
-  /* We use our own buffer as hmac_context instead of a dynamic buffer
-   * created by dtls_hmac_new() to separate storage space for cookie
-   * creation from storage that is used in real sessions. Note that
-   * the buffer size must fit with the default hash algorithm (see
-   * implementation of dtls_hmac_context_new()). */
-
-  dtls_hmac_context_t hmac_context;
-  dtls_hmac_init(&hmac_context, ctx->cookie_secret, DTLS_COOKIE_SECRET_LENGTH);
-
-  dtls_hmac_update(&hmac_context,
-		   (unsigned char *)dtls_session_get_address(session),
-                   dtls_session_get_address_size(session));
-
-  /* feed in the beginning of the Client Hello up to and including the
-     session id */
-  e = sizeof(dtls_client_hello_t);
-  e += (*(msg + DTLS_HS_LENGTH + e) & 0xff) + sizeof(uint8_t);
-  if (e + DTLS_HS_LENGTH > msglen)
-    return dtls_alert_fatal_create(DTLS_ALERT_HANDSHAKE_FAILURE);
-
-  dtls_hmac_update(&hmac_context, msg + DTLS_HS_LENGTH, e);
-  
-  /* skip cookie bytes and length byte */
-  e += *(uint8_t *)(msg + DTLS_HS_LENGTH + e) & 0xff;
-  e += sizeof(uint8_t);
-  if (e + DTLS_HS_LENGTH > msglen)
-    return dtls_alert_fatal_create(DTLS_ALERT_HANDSHAKE_FAILURE);
-
-  dtls_hmac_update(&hmac_context, 
-		   msg + DTLS_HS_LENGTH + e,
-		   dtls_get_fragment_length(DTLS_HANDSHAKE_HEADER(msg)) - e);
-
-  len = dtls_hmac_finalize(&hmac_context, buf);
-
-  if (len < *clen) {
-    memset(cookie + len, 0, *clen - len);
-    *clen = len;
-  }
-  
-  memcpy(cookie, buf, *clen);
-  return 0;
+    static const uint8_t fuzzing_cookie[16] = {0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+                                              0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01};
+    if (*clen >= sizeof(fuzzing_cookie)) {
+        memcpy(cookie, fuzzing_cookie, sizeof(fuzzing_cookie));
+        *clen = sizeof(fuzzing_cookie);
+        return 0;
+    } else {
+        return -1;
+    }
 }
 
 #ifdef DTLS_CHECK_CONTENTTYPE
@@ -1829,9 +1784,9 @@
   /* Set server random: First 4 bytes are the server's Unix timestamp,
    * followed by 28 bytes of generate random data. */
   dtls_ticks(&now);
-  dtls_int_to_uint32(handshake->tmp.random.server, now / DTLS_TICKS_PER_SECOND);
-  dtls_fill_random(handshake->tmp.random.server + 4, 28);
-
+  //dtls_int_to_uint32(handshake->tmp.random.server, now / DTLS_TICKS_PER_SECOND);
+  //dtls_fill_random(handshake->tmp.random.server + 4, 28);
+  memset(handshake->tmp.random.server, 0x01, 32);
   memcpy(p, handshake->tmp.random.server, DTLS_RANDOM_LENGTH);
   p += DTLS_RANDOM_LENGTH;
 
